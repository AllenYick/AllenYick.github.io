<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AllenYick's blog]]></title>
  <subtitle><![CDATA[record the time | enjoy the life]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://whatsme.net/"/>
  <updated>2015-11-29T05:52:38.607Z</updated>
  <id>http://whatsme.net/</id>
  
  <author>
    <name><![CDATA[AllenYick]]></name>
    <email><![CDATA[yikedll@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Machine Learning 概览]]></title>
    <link href="http://whatsme.net/2015/11/29/Machine-Learning-%E6%A6%82%E8%A7%88/"/>
    <id>http://whatsme.net/2015/11/29/Machine-Learning-概览/</id>
    <published>2015-11-29T02:16:12.000Z</published>
    <updated>2015-11-29T05:52:38.607Z</updated>
    <content type="html"><![CDATA[<p>近些年来，得益于互联网的普及，我们可以非常轻松地获取大量文本、音乐、图片、视频等各种各样的数据。机器学习，就是让计算机具有像人一样的学习能力的技术，是从堆积如山的数据（大数据）中寻找有用知识的数据挖掘技术。通过运用机器学习技术，从视频数据库中寻找自己喜欢的视频资料，或者根据用户购买记录向用户推荐其他相关产品等成为了现实。接下来从宏观的角度对什么是机器学习做相应的介绍，并对机器学习的基本概念进行说明。<br><a id="more"></a></p>
<h2 id="1-1_学习的种类">1.1 学习的种类</h2><p>计算机的学习，根据所处理的数据种类的不同，可以分为监督学习、无监督学习和强化学习等几种类型。</p>
<p><strong>监督学习</strong>，通俗的讲是指由求知欲的学生从老师那里获取知识、信息，老师提供对错提示，告知最终答案的过程。在机器学习中，学生对应于计算机，老师对应于周围环境。根据在学习过程中所获得的经验、技能，对没有学习过的问题也可以做出正确的回答，是计算机获得这种泛化能力，是监督学习的最终目标。监督学习，在手写文字识别、声音处理、图像处理、垃圾邮件分类与拦截，网页检索、基因诊断以及股票预测等各个方面，都有着广泛的应用。这一类机器学习的典型任务包括：预测数值型数据的回归，预测分类标签的分类，预测顺序的排序等。</p>
<p><strong>无监督学习</strong>，是指在没有老师的指导下，学习自学的过程。在机器学习里，基本上都是计算机在互联网中自动收集信息，并从中获取有用的信息。无监督学习不仅仅局限于解决像监督学习那样的有明确答案的问题，因此，它的学习目标可以不必十分明确。无监督学习在人造卫星故障诊断、视频分析、社交网站解析和声音信号解析等方面大显身手的同时，在数据可视化以及作为监督学习方法的前处理工具方面，也有广泛的应用。这一类机器学习的典型任务有聚类、异常检测等。</p>
<p><strong>强化学习</strong>，与监督学习类似，也以使计算机获得对没有学习过的问题作出正确解答的泛化能力为目标，但在学习过程中，不设置老师提示对错，告知最终答案的环节。然而，如果真的在学习过程中不能从环境中获得任何信息的话，强化学习就变成无监督学习了。强化学习，是指在没有老师直到的情况下，自己对预测的结果进行评估的方法。通过这样的自我评估，学生为了获得老师的最高嘉奖而不断地进行学习。强化学习，在机器人的自动控制、计算机游戏中的人工智能、市场战略的最优化等方面均有广泛的应用。在强化学习中国经常会用到回归、分类、聚类、和降维等各种机器学习算法。</p>
<h2 id="1-2_机器学习任务的例子">1.2 机器学习任务的例子</h2><p>下面主要讲解机器学习中典型的任务，例如回归、分类、聚类、异常检测、聚类和降维等。</p>
<p><strong>回归</strong>，是指把实函数在样本点附近加以近似的有监督的函数近似问题。考虑以$d$维实向量$\boldsymbol{x}$作为输入，实数值$y$作为输出的函数$ y=f(\boldsymbol{x}) $的学习问题。在监督学习里，这里的真实函数关系$f$是未知的，作为训练集的输入输出样本$\lbrace(\boldsymbol{x_i}, y<em>i)\rbrace</em>{i=1}^{n}$是已知的。</p>
<p><strong>分类</strong>，是指对于指定的模式进行识别的有监督的模式识别问题。在这里，以$d$维实向量$\boldsymbol{x}$作为输入样本，而所有的输入样本，可以划分为$c$个类别的问题进行说明，作为训练集的输入输出样本$\lbrace(\boldsymbol{x_i}, y<em>i)\rbrace</em>{i=1}^{n}$是已知的。但是，分类问题中的输出样本$y_i$，并不是具体的实数，而是分别代表类别$1,2, \ldots ,c$。在这样的任务里，得到输出类别$1,2, \ldots ,c$的函数$ y=f(\boldsymbol{x}) $的过程。</p>
<p><strong>异常检测</strong>，是指寻找输入样本$\lbrace\boldsymbol{x<em>i}\rbrace</em>{i=1}^{n}$中所包含的异常数据的问题。在已知正常数据与异常数据例子的情况下，其与有监督的分类问题是相同的。但是，在一般情况下，对于什么样的数据是异常的，什么样的数据是正常的，在事先是未知的。在这样的无监督的异常检测问题中，一般采用密度估计的方法，把靠近密度中心的数据作为正常数据，把偏离密度中心的数据作为异常数据。</p>
<p><strong>聚类</strong>，与分类问题相同，也是模式识别问题，但是属于无监督学习的一种。即只给出输入样本$\lbrace\boldsymbol{x<em>i}\rbrace</em>{i=1}^{n}$，然后判断各个样本分别属于$1,2, \ldots ,c$中的哪个簇。隶属于相同簇的样本之间具有相似性的性质，不同簇之间具有不同的性质。在聚类问题中，如何准确地计算样本之间的相似度是很重要的课题。</p>
<p>参考文献：<br>[1] 图解机器学习<br>[2] <a href="http://pages.cs.wisc.edu/~jerryzhu/pub/sslicml07.pdf‎" target="_blank" rel="external">Semi-Supervised Learning Tutorial</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近些年来，得益于互联网的普及，我们可以非常轻松地获取大量文本、音乐、图片、视频等各种各样的数据。机器学习，就是让计算机具有像人一样的学习能力的技术，是从堆积如山的数据（大数据）中寻找有用知识的数据挖掘技术。通过运用机器学习技术，从视频数据库中寻找自己喜欢的视频资料，或者根据用户购买记录向用户推荐其他相关产品等成为了现实。接下来从宏观的角度对什么是机器学习做相应的介绍，并对机器学习的基本概念进行说明。<br>]]>
    
    </summary>
    
      <category term="machine learning" scheme="http://whatsme.net/tags/machine-learning/"/>
    
      <category term="academic" scheme="http://whatsme.net/categories/academic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Range Sum Query]]></title>
    <link href="http://whatsme.net/2015/11/28/Range-Sum-Query/"/>
    <id>http://whatsme.net/2015/11/28/Range-Sum-Query/</id>
    <published>2015-11-28T05:56:19.000Z</published>
    <updated>2015-11-29T04:19:28.826Z</updated>
    <content type="html"><![CDATA[<p>Range Sum Query, 对一个整数序列，给定范围对其求和。根据序列的维度可分为一维、二维和多维，根据元素是否可以改变分为Immutable和Mutable，我们只讨论一维和二维的情况。<br><a id="more"></a></p>
<h2 id="1-_1D,_Immutable（一维，数据不可变）">1. 1D, Immutable（一维，数据不可变）</h2><blockquote>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p><strong>Example:</strong><br>Given nums = [-2, 0, 3, -5, 2, -1]</p>
<p>sumRange(0, 2) -&gt; 1<br>sumRange(2, 5) -&gt; -1<br>sumRange(0, 5) -&gt; -3<br><strong>Note:</strong></p>
<ol>
<li>You may assume that the array does not change.</li>
<li>There are many calls to sumRange function.</li>
</ol>
</blockquote>
<h3 id="Analysis">Analysis</h3><p>如果采取<em>brute-force</em>, 在每次query的时候，则需要用O(n)的时间复杂度计算sumRange(i, j)，整个时间复杂度就为O(n^2),这样做必然是会超时，因此这种方法不可行。</p>
<p>这种方法在每次query的时候都需要将i到j的元素累加，比如第一次query的是(0,2)，第二次query的是(0,3), 我们可以发现第二次的计算是可以利用第一次的结果的。因此可以对算法进行改进，在一开始进行适当的计算，并保存结果，在增加空间复杂度的前提下减小时间复杂度。最后在query的时候就可以节省大量时间了，那么关键是我们要保存什么信息呢？<br>可以发现：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sumRange</span><span class="params">(i, j)</span></span> = <span class="function"><span class="title">sumRange</span><span class="params">(<span class="number">0</span>, j)</span></span> - <span class="function"><span class="title">sumRange</span><span class="params">(<span class="number">0</span>, i-<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>假如我们已经计算了每个sumRange(0, k),那么我们既可以在O(1)的算法时间复杂度内完成query。计算所有的sumRange(0, k)可以利用动态规划，O(n)的时间即可完成。因此整个算法的时间复杂度为O(n)，空间复杂度也为O(n)。</p>
<h3 id="Cpp_Code">Cpp Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NumArray &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        cusums.resize(n+<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// cusums[0]=0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cusums[i] += cusums[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cusums[j+<span class="number">1</span>]-cusums[i];</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cusums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<h2 id="2-_2D,_Immutable（二维，数据不可变）">2. 2D, Immutable（二维，数据不可变）</h2><blockquote>
<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).<br><img src="/images/range_sum_query_2d.png" alt="Range Sum Query 2D" style="width: 200px;"><br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<p><strong>Example:</strong><br>Given matrix = [<br>    [3, 0, 1, 4, 2],<br>    [5, 6, 3, 2, 1],<br>    [1, 2, 0, 1, 5],<br>    [4, 1, 0, 1, 7],<br>    [1, 0, 3, 0, 5]<br>]<br>sumRegion(2, 1, 4, 3) -&gt; 8<br>sumRegion(1, 1, 2, 2) -&gt; 11<br>sumRegion(1, 2, 2, 4) -&gt; 12<br><strong>Note:</strong><br>You may assume that the matrix does not change.<br>There are many calls to sumRegion function.<br>You may assume that row1 ≤ row2 and col1 ≤ col2.</p>
</blockquote>
<h3 id="Analysis-1">Analysis</h3><p>与1维的处理方法相同，只不过二维的情形需要O(n^2)的时间预处理。主要利用一下公式：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sumRegion</span><span class="params">(row1, col1, row2, col2)</span></span> = </span><br><span class="line">                          <span class="function"><span class="title">sumRegion</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, row2, col1)</span></span></span><br><span class="line">                        + <span class="function"><span class="title">sumRegion</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, row1, col2)</span></span></span><br><span class="line">                        - <span class="function"><span class="title">sumRegion</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, row1, col1)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在实际处理中，定义积分图矩阵integrogram的第一行和第一列为0,方便使用统一公式处理，不用讨论为0的情况。</p>
<h3 id="Cpp_Code-1">Cpp Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NumMatrix &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix) &#123;</span><br><span class="line">        n = matrix.size();</span><br><span class="line">        m = n != <span class="number">0</span> ? matrix[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        integrogram.resize(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));  <span class="comment">// 第一行，第一列为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                integrogram[i][j] = integrogram[i-<span class="number">1</span>][j] </span><br><span class="line">                                  + integrogram[i][j-<span class="number">1</span>] </span><br><span class="line">                                  - integrogram[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                                  + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row1 &lt; <span class="number">0</span> || col1 &lt; <span class="number">0</span> || row2 &gt; n || col2 &gt; m)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> integrogram[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - integrogram[row2+<span class="number">1</span>][col1] - integrogram[row1][col2+<span class="number">1</span>] + integrogram[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; integrogram;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumMatrix numMatrix(matrix);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(0, 1, 2, 3);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(1, 2, 3, 4);</span></span><br></pre></td></tr></table></figure>
<h2 id="3-_1D,_Mutable_(一维，数据可变)">3. 1D, Mutable (一维，数据可变)</h2><blockquote>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>The update(i, val) function modifies nums by updating the element at index i to val.<br><strong>Example:</strong><br>Given nums = [1, 3, 5]</p>
<p>sumRange(0, 2) -&gt; 9<br>update(1, 2)<br>sumRange(0, 2) -&gt; 8<br><strong>Note:</strong></p>
<ol>
<li>The array is only modifiable by the update function.</li>
<li>You may assume the number of calls to update and sumRange function is distributed evenly.</li>
</ol>
</blockquote>
<h3 id="Analysis-2">Analysis</h3><p>在Immutable的基础上，增加了<strong>update(index, value)</strong>， 即可以改变序列中任何位置的值。显然如果再使用刚才的算法，由于update的最大时间复杂度为O(n),因此整个算法的时间复杂度就增加到了O(n^2),因此需要一个复杂度更低的算法。可以从两方面入手<em>update</em>和<em>query</em>。需要将这两个函数的复杂度都降低到O(logn)以下(包括O(logn))。前面已经提到过需要<strong>*事先进行一些预处理，使得一些重复计算的东西不再重复计算，才能够将复杂度降低下来</strong>。</p>
<p>先预先计算一些区间的和值，然后把每个询问都拆成若干个计算了和的区间，并且将这些区间的和再相加，从而得出答案。这不就是线段树的思想吗？那就先从线段树说起。</p>
<p>线段树其实本质就是用一棵树来维护一段区间上和某个子区间相关的值——例如区间和、区间最大最小值一类的。它的具体做法是这样的，这棵树的根节点表示了整段区间，根节点的左儿子节点表示了这段区间的前半部分，根节点的右儿子节点表示了这段区间的后半部分——并以此类推，对于这棵树的每个节点，如果这个节点所表示的区间的长度大于1，则令其左儿子节点表示这段区间的前半部分，令其右儿子表示这段区间的后半部分。以一段长度为10的区间为例，所建立出的线段树应该是这样子的。<br><img src="/images/segment_tree_1.png" alt="segment tree" style="width: 450px;"><br>就以RSQ(Range Sum Query)问题为例吧——RSQ问题要求的是求解一段区间中的和值，那么我不妨效仿ST算法，先对一些可能会用到的区间求解这个和值！而既然我要是用线段树来解决这个问题的，那么我不妨就将每一个节点对应的区间中的和值都求解出来。</p>
<p>那给定这样一组数据，将这个预处理的结果给我计算一下？<br><strong>N=10</strong><br><strong>Weight = {3, 2, 9, 6, 7, 5, 4, 1, 8, 10}</strong><br>这数据正好也只有10个位置，那么直接用这棵树了。由于每个非叶子节点所对应的区间都正好由它的两个儿子节点所对应的区间拼凑而成，这样一个节点所对应的区间中的和值便是它的两个儿子节点所对应的区间的和。这样我只需要O(N)的时间复杂度就可以计算出这棵树来。”<br><img src="/images/segment_tree_2.png" style="width: 450px;"><br>这样一棵树统计出来的区间怎样使用很快的算法进行查询？还有修改呢？”</p>
<p>先从简单的说起吧——<strong>修改</strong>，当某个位置的商品的重量发生改变的时候，对应的，就是这棵树的某个叶子节点的值发生了变化，包含这个节点的区间，便只有这个节点的所有祖先节点，而这样的节点数量事实上是很少的——只有O(log(N))级别。也就是说，当一次修改操作发生的时候，我只需要改变数量在O(log(N))级别的节点的值就可以完成操作了，修改的时间复杂度是O(log(N))。”</p>
<p><strong>查询</strong>这个问题其实也不复杂！从线段树的根开始，对于当前访问的线段树节点t, 设其对应的区间为[A, B], 如果询问的区间[l, r]完全处于前半段或者后半段——即r &lt;= (A + B)/2或者l &gt; (A + B) / 2，那么递归进入t对应的子节点进行处理（因为另一棵子树中显然不会有任何区间需要用到）。否则的话，则把询问区间分成2部分[l, (A + B) / 2]和[(A + B) / 2 + 1, r]，并且分别进入t的左右子树处理这两段询问区间（因为2棵子树中显然都有区间需要用到）！当然了，如果[A, B]正好覆盖了[l, r]的话，就可以直接返回之前计算的t这棵子树中的和值了。还是之前那个例子，如果我要询问[3, 9]这段区间，我的最终结果会是这样的——橙色部分标注的区间。<br><img src="/images/segment_tree_3.png" style="width: 450px;"><br>首先[3, 9]分解成了[3, 5]和[6, 9]两个区间，而[3, 5]分解成了[3, 3]和[4, 5]——均没有必要继续分解，[6, 9]分解成了[6, 8]和[9, 9]——同样也没有必要继续分解了。每一步的分解都是必要的，所以这已经是最好的分解方法了。”</p>
<p>但是这样分解的话，区间的个数能保证么？万一很多怎么办？其实不会的，除了第一次分解成2个区间的操作可能会将区间个数翻倍外，之后每一次分解的时候所处理的区间都肯定有一条边是和当前节点对应的重合的（即l=A或者r=B），也就是说即使再进行分解，分解出的两个区间中也一定会有一个区间是不需要再进行分解的，也就是区间的总数是在深度这个级别的，所以也是O(logN)的。</p>
<p>再总结一下，首先根据初始数据，使用O(N)的时间构建一棵最原始的线段树，这个过程中我会使用子节点的值来计算父亲节点的值，从而避免冗余计算。然后对于每一次操作，如果是一次修改的话，我就将修改的节点和这个节点的所有祖先节点的值都进行更新，可以用O(logN)的时间复杂度完成。而如果是一次询问的话，使用上面描述的方法来对询问区间进行分解，用O(logN)的时间复杂度完成。无论是修改还是查询的时间复杂度都是O(logN)的，所以我这个算法最终的时间复杂度会是O(N + Q * log(N))。</p>
<h3 id="Cpp_Code-2">Cpp Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NumArray &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构建SegmentTree</span></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        segmentTree.resize(n * <span class="number">4</span> + <span class="number">1</span>);   <span class="comment">// 4n的空间足够存储SegmentTree</span></span><br><span class="line">        createTree(<span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(<span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &gt; n-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 沿根结点向下查询</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == i &amp;&amp; end == j)</span><br><span class="line">            <span class="keyword">return</span> segmentTree[node];</span><br><span class="line">        <span class="keyword">int</span> mid = (begin+end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &lt;= mid)    <span class="comment">// 位于左子树</span></span><br><span class="line">            <span class="keyword">return</span> query((node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, begin, mid, i, j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; mid) <span class="comment">// 位于右子树</span></span><br><span class="line">            <span class="keyword">return</span> query((node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>, mid+<span class="number">1</span>, end, i, j);</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 位于左子树和右子树</span></span><br><span class="line">            <span class="keyword">return</span> query((node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, begin, mid, i, mid)</span><br><span class="line">        + query((node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>, mid+<span class="number">1</span>, end, mid+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沿着根结点向下更新，直到叶子结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> id, <span class="keyword">int</span> val)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &lt; begin || id &gt; end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(begin == end)</span><br><span class="line">            segmentTree[node] = val;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            update((node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, begin, (begin+end)&gt;&gt;<span class="number">1</span>, id, val);</span><br><span class="line">            update((node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>, ((begin+end)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, end, id, val);</span><br><span class="line">            segmentTree[node] = segmentTree[(node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] + segmentTree[(node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建SegmentTree</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end &lt; begin)   <span class="comment">// illegal</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(begin == end) <span class="comment">//叶子结点</span></span><br><span class="line">            segmentTree[node] = nums[begin];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归构建左右子树</span></span><br><span class="line">            createTree((node &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, begin, (begin+end)&gt;&gt;<span class="number">1</span>, nums);</span><br><span class="line">            createTree((node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>, ((begin+end)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, end, nums);</span><br><span class="line">            segmentTree[node] = segmentTree[(node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] + segmentTree[(node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; segmentTree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.update(1, 10);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<p><strong>Summary</strong><br>对于本题，有人提出了一种基于bucket的方法，更新和查询分别需要O(1)和O(n^0.5)时间复杂度的算法<a href="https://leetcode.com/discuss/70272/solution-using-buckets-updating-for-query-the-worst-case-fast" target="_blank" rel="external">(more)</a>如果将求和该为求最大或最小值，即变成了RMQ问题，同样的算法，只需修改几个地方，就不再赘述，对于RMQ，还有经典的<a href="http://hihocoder.com/contest/hiho16/problem/1" target="_blank" rel="external">ST算法</a>。<br>另二维，数据可变的情况没有列出，读者可以自己思考。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Range Sum Query, 对一个整数序列，给定范围对其求和。根据序列的维度可分为一维、二维和多维，根据元素是否可以改变分为Immutable和Mutable，我们只讨论一维和二维的情况。<br>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://whatsme.net/tags/algorithm/"/>
    
      <category term="tech" scheme="http://whatsme.net/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Additive Number]]></title>
    <link href="http://whatsme.net/2015/11/27/Additive-number/"/>
    <id>http://whatsme.net/2015/11/27/Additive-number/</id>
    <published>2015-11-27T05:03:02.000Z</published>
    <updated>2015-11-28T14:10:12.821Z</updated>
    <content type="html"><![CDATA[<h2 id="Source">Source</h2><blockquote>
<p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p><strong>For example:</strong><br>“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.<br><em>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</em></p>
<p>“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.<br><em>1 + 99 = 100, 99 + 100 = 199</em></p>
<p><strong>Note:</strong> Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.<br>More: <a href="https://leetcode.com/problems/additive-number/" target="_blank" rel="external">leetcode</a></p>
</blockquote>
<a id="more"></a>
<h2 id="My_Solution">My Solution</h2><p>给定一个字符串，该字符串只包含0~9的字符，判断该字符串会否为“可加”的。“可加”的定义如下：将字符串序列分解为整数（至少三个），除了前两个，其余的每个数都是它前两个数之和。<br>根据字符串的不同分解，可构造一棵解答树，再利用深度优先搜索寻找答案，注意处理以下几点。</p>
<hr>
<ul>
<li>‘0x’是非法的；</li>
<li>数的长度越长，值越大，利用此性质可以有效的剪枝；</li>
<li>至少包含三个数。</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAdditiveNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span> )          <span class="comment">// three numbers at least</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>)   <span class="comment">// "0x" is illegal</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i+j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> first = str2int(num.substr(<span class="number">0</span>, i));</span><br><span class="line">                <span class="keyword">int</span> second = str2int(num.substr(i, j));</span><br><span class="line">                <span class="keyword">if</span>(dfs(num, first, second, i+j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// depth-first search</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> idx)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first+second == str2int(num.substr(idx)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.size()-idx+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[idx] == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> third = str2int(num.substr(idx, i));</span><br><span class="line">            <span class="keyword">if</span>(first+second == third)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(num, second, third, idx+i))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(first+second &lt; third) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// string to int</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">str2int</span><span class="params">(<span class="built_in">string</span> str)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.size();  </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || (str[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; n &gt; <span class="number">1</span>) )</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">            res = res*<span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Source">Source</h2><blockquote>
<p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p><strong>For example:</strong><br>“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.<br><em>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</em></p>
<p>“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.<br><em>1 + 99 = 100, 99 + 100 = 199</em></p>
<p><strong>Note:</strong> Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.<br>More: <a href="https://leetcode.com/problems/additive-number/">leetcode</a></p>
</blockquote>]]>
    
    </summary>
    
      <category term="leetcode" scheme="http://whatsme.net/tags/leetcode/"/>
    
      <category term="tech" scheme="http://whatsme.net/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://whatsme.net/2015/10/28/hello-world/"/>
    <id>http://whatsme.net/2015/10/28/hello-world/</id>
    <published>2015-10-28T13:58:11.636Z</published>
    <updated>2015-10-27T05:27:49.854Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AllenYick's blog]]></title>
  <subtitle><![CDATA[record the time | enjoy the life]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://whatsme.net/"/>
  <updated>2015-12-01T14:20:18.472Z</updated>
  <id>http://whatsme.net/</id>
  
  <author>
    <name><![CDATA[AllenYick]]></name>
    <email><![CDATA[yikedll@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[auto 与 decltype]]></title>
    <link href="http://whatsme.net/2015/11/30/auto-%E4%B8%8E-decltype/"/>
    <id>http://whatsme.net/2015/11/30/auto-与-decltype/</id>
    <published>2015-11-30T13:56:26.000Z</published>
    <updated>2015-12-01T14:20:18.472Z</updated>
    <content type="html"><![CDATA[<p>本文将介绍C++11中两个与类型有关的关键字，<strong>auto</strong> 与 <strong>decltype</strong> ，以及C++11中新提出的<strong>类型推导</strong>的概念。</p>
<h1 id="1_auto">1 auto</h1><p>说到C++11的新特性，从使用方便的角度，不得不提的就是auto。auto在C++11中与C++98中完全是两种概念。在C++98中是一种<strong>存储类型指示符</strong>（storage-class-specifier,如static、extern、thread_local等）， 而在C++11中是一种新的<strong>类型指示符</strong>（type-specifier, 如int, float, char等）。只是，auto声明变量的类型必须由编译器在编译时期推导而得。另一个与类型有关的则是 decltype，下面分别介绍这两个关键字的用法。<br><a id="more"></a></p>
<h2 id="1-1_auto类型推导">1.1 auto类型推导</h2><p>在编程语言中，C/C++常被冠以“静态类型”，的称号，而像Python类的语言则被称为“动态类型”的。通常情况下，“静”和“动”的区别非常直观。先看看如下的Python代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'world\n'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'hello, %s'</span> % name</span><br></pre></td></tr></table></figure></p>
<p>这是Python的一个”hello world”实现。代码使用了一个变量<em>name</em>，在使用前并没有进行过任何声明，而当使用时，可以直接拿来就用。</p>
<h3 id="1-1-1_静态类型和动态类型">1.1.1 静态类型和动态类型</h3><p>这种变量的使用方式非常随性，而在C/C++程序员眼中，每个变量使用前都必须声明（或定义的同时声明）几乎是天经地义的事，这样通常被视为编程语言的 <strong>“静态类型”</strong> 的体现。而对于Python、Perl、JavaScript等语言中变量不需要声明，而几乎<strong>“拿来就用”</strong> 的变量方式，则被视为是编程语言中的 <strong>“动态类型”</strong> 的体现。不过从技术上严格地讲，静态类型和动态类型的主要区别在于对变量进行类型检查的时间点。对于静态类型，类型检查主要发生在编译阶段；而对于动态类型，类型检查主要发生在运行阶段。形如Python等语言中变量“拿来就用”的特性，则需要归功于一个技术，即<strong>类型推导</strong>。</p>
<p>事实上，类型推导也可以用与静态类型的语言中。比如在上面的 Python 代码中，即使没有对 name 进行事先的类型声明，如果按照 C/C++ 程序员的思考方式，”world\n”表达式应返回一个临时字符串，所以即使name没有进行类型声明，也能轻松推导出name的类型应该是一个字符串类型。在C++11中，重定义了auto关键字，实现了类型的推导，另一个实现是 decltype，将在后面详细叙述。</p>
<p>可以使用C++11的方式实现刚才的Python代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> name = <span class="string">"world\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, "</span> &lt;&lt; name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项: g++ -std=c++11 auto-test-1.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>这里使用了auto关键字来要求编译器对变量name的类型进行自动推导。编译器根据它的初始化表达式的类型，推导出name的类型为<strong> char* </strong>。</p>
<p>auto类型推导的基本用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="number">1</span>;     <span class="comment">// x的类型为 int</span></span><br><span class="line">    <span class="keyword">auto</span> y = foo(); <span class="comment">// y的类型为 double</span></span><br><span class="line">    <span class="keyword">struct</span> m &#123; <span class="keyword">int</span> i; &#125;str;</span><br><span class="line">    suto str1 = str;  <span class="comment">// str1的类型是 struct m</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> z;  <span class="comment">//无法推导，无法通过编译 </span></span><br><span class="line">    z = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项: g++ -std=c++11 auto-test-2.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>变量x被初始化为1，因为字面常量1的类型为 const int，所以编译器推导出x的类型为int（这里const类型限制符被去掉了，后面会解释）。同理y被推导为double类型，str1被推导为struct m。而变量z，我们使用auto “声明” z，但不立即对其进行定义，此时编译器会报错。表明auto声明的变量必须被初始化，以使编译器能够从初始化表达式中推导出其类型。从这个意义上讲auto并非一种类型声明，而是一个类型声明时的占位符，编译器在编译时期会将auto替换为变量实际的类型。</p>
<h2 id="1-2_auto的优势">1.2 auto的优势</h2><h3 id="1-2-1_简化复杂类型变量的声明">1.2.1 简化复杂类型变量的声明</h3><p>假如我们定义了这样的一个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopover</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;vs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator i = vs.begin();</span><br><span class="line">    <span class="keyword">for</span>(; i != vs.end(); i++)</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们以 vs.begin() 初始化迭代器i的值，然而在定义i的时候不得不写出 std::vector&lt; std::string &gt;::iterator 这样的声明。这样冗长的代码可读性自然很低，就算使用了 using namespace std，情况也好不到那里去， 如果使用auto的话，代码可读性可以成倍增加。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopover</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;vs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> i = vs.begin(); i != vs.end(); i++)</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在for循环中，i 的类型将由vs.begin()推导出，这样的代码更清晰可读。</p>
<h3 id="1-2-2_免除类型声明时的麻烦，避免类型声明时的错误">1.2.2 免除类型声明时的麻烦，避免类型声明时的错误</h3><p>先看这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> PI&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">double</span> <span class="keyword">operator</span>* (<span class="keyword">float</span> v)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="keyword">double</span>)val * v;  <span class="comment">// 这里扩展了精度</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">float</span> val = <span class="number">3.1415927f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">float</span> radius = <span class="number">1.7e10</span>;</span><br><span class="line">   PI pi;</span><br><span class="line">   <span class="keyword">auto</span> circumference = <span class="number">2</span> * (pi * radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了 float 类型的变量 radius （半径）以及一个自定义类型的 PI 变量 pi ，使用 auto 类型定义变量 circumference ，在 pi 与 radius 相乘时，其返回值是 double。而 PI 的定义有可能在其他地方， main 函数作者也许为避免数据上溢或者精度降低而使用 double，这样不会有问题，而使用了 float 类型声明就可能享受不了 PI 作者细心设计带来的好处，将 circumference声明为auto则毫无问题。</p>
<h3 id="1-2-3_自适应，支持泛型编程">1.2.3 自适应，支持泛型编程</h3><p>当 auto 应用于模板的定义中，其“自适应”性会得到更加充分的体现。看看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s = t1 + t2;    <span class="comment">// s 的类型会在模板实例化是被推导出来</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = <span class="number">2L</span>L;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.0f</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">4.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> e = Sum&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt;(a, b);      <span class="comment">// e 的类型被推导为long</span></span><br><span class="line">    <span class="keyword">auto</span> f = Sum&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;(c, d);  <span class="comment">// f 的类型被推导为double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于T1、T2的类型要在模板实例化时才能确定，所以在Sum中将s声明为auto类型。</p>
<h2 id="1-3_auto使用细则">1.3 auto使用细则</h2><h3 id="1-3-1_auto类型指示符与指针和引用之间的关系">1.3.1 auto类型指示符与指针和引用之间的关系</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> * y = &amp;x;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> * a= &amp;x;   <span class="comment">// a: int *</span></span><br><span class="line"><span class="keyword">auto</span> &amp; b = x;   <span class="comment">// b: int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> c = y;     <span class="comment">// c: int *</span></span><br><span class="line"><span class="keyword">auto</span> * d = y;   <span class="comment">// d: int *</span></span><br><span class="line"><span class="keyword">auto</span> * e = &amp;foo();  <span class="comment">// 指针不能指向临时变量</span></span><br><span class="line"><span class="keyword">auto</span> &amp; f = foo();   <span class="comment">// nonconst 的左值引用不能绑定一个临时变量</span></span><br><span class="line"><span class="keyword">auto</span> g = bar();     <span class="comment">// g: int</span></span><br><span class="line"><span class="keyword">auto</span> &amp; h = bar();   <span class="comment">// h: int &amp;</span></span><br></pre></td></tr></table></figure>
<p>可以看出 auto* 与 auto 并没有什么区别，如果要使得auto声明的变量是另一个变量的引用，则必须使用 auto&amp;。</p>
<h3 id="1-3-2_auto_与_volatile_和_const_之间的关系">1.3.2 auto 与 volatile 和 const 之间的关系</h3><p>volatile 和 const 代表两种不同的属性：易失性和常量性，在C++标准中，它们常被一起叫做cv限制符（cv-qulifier）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> * <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> a = foo();         <span class="comment">// a: const double</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; b = foo();       <span class="comment">// b: cosnt double &amp;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> * c = bar();    <span class="comment">// c: volatile float *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = a;                   <span class="comment">// d: double</span></span><br><span class="line"><span class="keyword">auto</span> &amp; e = a;                 <span class="comment">// e: const double &amp;</span></span><br><span class="line"><span class="keyword">auto</span> f = c;                   <span class="comment">// f: float *</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> &amp; g = c;        <span class="comment">// g: volatile float * &amp;</span></span><br></pre></td></tr></table></figure>
<p>可以看出，auto可以和cv限制符一起使用，可以通过非cv限制的类型初始化一个cv限制的类型。不过通过auto声明的变量d，f却无法带走a和f的常量性和易失性。这里的例外还是引用，可以看出，声明为引用的变量e，g都保持了其引用对象的属性。</p>
<h3 id="1-3-3_auto的其他规则">1.3.3 auto的其他规则</h3><p>此外，同一赋值语句中，auto可以用来声明多个变量的类型，不过这些变量的类型必须相同。如果类型不同，则会编译错误。事实上，用auto来声明多个变量是，只有第一个变量用于类型推导，然后推导出来的数据类型被作用于其他的变量。所以不允许这些变量的类型不同。其实每个 auto 都写一行是最好的做法，可读性也好。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>, j = <span class="number">2</span>;  <span class="comment">// i,j均为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>, y = <span class="number">1.2f</span>;    <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> o = <span class="number">1</span>, &amp;p = o, *q = &amp;p;  <span class="comment">// 从左向右推导</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// m是指向const int的指针，n是int型变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* m = &amp;x, n = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-4_auto不能推导的情况">1.3.4 auto不能推导的情况</h3><p>不过 auto 也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制。这些例外写在下面的代码中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">auto</span> x = <span class="number">1</span>)</span> </span>&#123;&#125;  <span class="comment">// 1: auto 函数参数，编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> str&#123;</span><br><span class="line">    <span class="keyword">auto</span> var = <span class="number">10</span>;  <span class="comment">// 2: auto 非静态成员，编译失败</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">auto</span> y = x;</span><br><span class="line">    <span class="keyword">auto</span> z[<span class="number">3</span>] = x;  <span class="comment">// 3: auto 数组，编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4: auto 模板参数实例化时，编译失败</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">auto</span>&gt; v(<span class="number">2</span>, <span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上四种情况是auto不能推导的情况。</p>
<h1 id="2_decltype">2 decltype</h1><p>与auto类似，decltype 也能进行类型推导，不过这两者的使用方式却有一定的区别。先看如下这个简单的例子。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">decltype</span>(i) j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(j).name() &lt;&lt; endl;  <span class="comment">// 打印出"i", g++中表示int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">decltype</span>(a+b) c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(c).name() &lt;&lt; endl;  <span class="comment">// 打印出"d", g++中表示double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到变量j的类型由decltype(i)进行声明，表示j的类型跟i相同。而c的类型跟a+b这个表达式返回的类型相同。由于a+b返回double类型，则c也是double类型。</p>
<h2 id="2-1_decltype的应用">2.1 decltype的应用</h2><p>与 typedef/using 合用，常看到这样的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">size_t</span> = <span class="keyword">decltype</span>(<span class="keyword">sizeof</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ptrdiff_t</span> = <span class="keyword">decltype</span>((<span class="keyword">int</span>*)<span class="number">0</span> - (<span class="keyword">int</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">nullptr_t</span> = <span class="keyword">decltype</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里 size_t 以及 ptrdiff_t 还有 nullptr_t 都是由 decltype 推导出的类型。 </p>
<p>除此之外，decltype 在某些场景下，可以极大地增加代码的可读性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">typedef decltype(vec.begin()) vec_iter_type;</span><br><span class="line">for(vec_iter_type i = vec.begin(); i != vec.end(); i++)</span><br><span class="line">    // do something</span><br><span class="line">for(decltype(vec)::iterator i = vec.begin(); i != vec.end(); i++)</span><br><span class="line">    // do something</span><br></pre></td></tr></table></figure>
<p>可以看到 decltype(vec)::iterator 这样灵活的用法，和 auto 非常类似，也类似一种“占位符”式的替代。</p>
<p>另外，在C++中，有时会遇到匿名的类型，而拥有了 decltype 这个利器之后，重用匿名类型也非难事。看看如下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> &#123;K1, K2, K3&#125; anon_e;   <span class="comment">// enum class 为C++11新特性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">decltype</span>(anon_e) key;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125;anon_u;  <span class="comment">// 匿名的union联合体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">decltype</span>(anon_u) id;</span><br><span class="line">&#125;anon_s[<span class="number">100</span>];  <span class="comment">// 匿名的 struct 数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(anon_s) as;</span><br><span class="line">    as[<span class="number">0</span>].id.key = <span class="keyword">decltype</span>(anon_e)::K1;   <span class="comment">// 引用匿名强类型枚举中的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项： g++ -std=c++11</span></span><br></pre></td></tr></table></figure></p>
<p>进一步地，有了 decltype，可以适当扩大模板泛型的能力。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// s的类型被声明为 decltype(t1 + t2)</span><br><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">void Sum(T1 &amp; t1, T2 &amp; t2, decltype(t1+t2) &amp;s)&#123;</span><br><span class="line">    s = t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 3;</span><br><span class="line">    long long b = 5;</span><br><span class="line">    float c = 1.0f, d = 2.4f;</span><br><span class="line"></span><br><span class="line">    long long e;</span><br><span class="line">    float f;</span><br><span class="line">    Sum(a, b, e);  // s的类型被推导为long log</span><br><span class="line">    Sum(c, d, f);  // s的类型被推导为float</span><br><span class="line">&#125;</span><br><span class="line">// 编译选项： g++ -std=c++11</span><br></pre></td></tr></table></figure>
<p>这样一来，Sum的适用范围增加，不过很明显，如果 t1 和 t2 是两个数组，t1+t2 不会是合法的表达式。因此应该为这些特殊情况提供其他的版本。</p>
<h2 id="2-2_decltype_推导四规则">2.2 decltype 推导四规则</h2><p>作为 auto 的伙伴，decltype 在C++11中也非常重要。不过跟auto一样，也有很多细则条款需要注意。最典型的例子如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">decltype</span>(i) a;    <span class="comment">// a: int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) b;  <span class="comment">// b: int &amp;, 无法编译通过</span></span><br><span class="line"><span class="comment">// 编译选项： g++ -std=c++11</span></span><br></pre></td></tr></table></figure></p>
<p>这里为什么编译器提示说 b 是 int &amp; 类型？因为没有初始化所以编译出错。而 a 则被正确推导为 int 类型。<strong>decltype(e)</strong> 进行类型推导时，编译器将依序判断以下四规则：</p>
<ul>
<li>1）如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么 decltype(e) 就是<strong> e 所命名的实体的类型</strong>。此外，如果 e 是一个被重载的函数，则会导致编译时错误。</li>
<li>2）否则，假设 e 的类型是T，如果 e 是一个将亡值(xvalue)，那么 decltype(e) 为<strong>T&amp;&amp;</strong>。</li>
<li>3）否则，假设 e 的类型是T，如果 e 是一个左值，则 decltype(e) 为<strong>T&amp;</strong>。</li>
<li>4）否则，假设 e 的类型是T，则 decltype(e) 为<strong>T</strong>。</li>
</ul>
<p>再回到以上代码，并结合 decltype 的推导规则，就可以知道，decltype((i)) b; 中，由于 (i) 不是一个标记符表达式，但却是一个左值表达式，因此，按照 decltype 推导规则3，其类型是一个 int 的引用。</p>
<p>总的来说， decltype 算得上是C++11中类型推导使用方式上最灵活的一种。虽然看起来推导规则有些复杂，有的时候跟 auto 推导结果还略不相同，但大多数时候，deltype 还是自然而亲切的。一些细则的区别，可以在使用时遇到问题再返回查验。</p>
<p>在<strong>追踪返回类型</strong>的函数定义中，将融合 auto 与 decltype, 将C++11中的泛型能力提升到更高的水平。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文将介绍C++11中两个与类型有关的关键字，<strong>auto</strong> 与 <strong>decltype</strong> ，以及C++11中新提出的<strong>类型推导</strong>的概念。</p>
<h1 id="1_auto">1 auto</h1><p>说到C++11的新特性，从使用方便的角度，不得不提的就是auto。auto在C++11中与C++98中完全是两种概念。在C++98中是一种<strong>存储类型指示符</strong>（storage-class-specifier,如static、extern、thread_local等）， 而在C++11中是一种新的<strong>类型指示符</strong>（type-specifier, 如int, float, char等）。只是，auto声明变量的类型必须由编译器在编译时期推导而得。另一个与类型有关的则是 decltype，下面分别介绍这两个关键字的用法。<br>]]>
    
    </summary>
    
      <category term="C++11" scheme="http://whatsme.net/tags/C-11/"/>
    
      <category term="tech" scheme="http://whatsme.net/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine Learning 概览]]></title>
    <link href="http://whatsme.net/2015/11/29/Machine-Learning-%E6%A6%82%E8%A7%88/"/>
    <id>http://whatsme.net/2015/11/29/Machine-Learning-概览/</id>
    <published>2015-11-29T02:16:12.000Z</published>
    <updated>2015-11-29T07:14:06.398Z</updated>
    <content type="html"><![CDATA[<p>近些年来，得益于互联网的普及，我们可以非常轻松地获取大量文本、音乐、图片、视频等各种各样的数据。机器学习，就是让计算机具有像人一样的学习能力的技术，是从堆积如山的数据（大数据）中寻找有用知识的数据挖掘技术。通过运用机器学习技术，从视频数据库中寻找自己喜欢的视频资料，或者根据用户购买记录向用户推荐其他相关产品等成为了现实。接下来从宏观的角度对什么是机器学习做相应的介绍，并对机器学习的基本概念进行说明。<br><a id="more"></a></p>
<h2 id="1-1_学习的种类">1.1 学习的种类</h2><p>计算机的学习，根据所处理的数据种类的不同，可以分为监督学习、无监督学习和强化学习等几种类型。</p>
<p><strong>监督学习</strong>，通俗的讲是指由求知欲的学生从老师那里获取知识、信息，老师提供对错提示，告知最终答案的过程。在机器学习中，学生对应于计算机，老师对应于周围环境。根据在学习过程中所获得的经验、技能，对没有学习过的问题也可以做出正确的回答，是计算机获得这种泛化能力，是监督学习的最终目标。监督学习，在手写文字识别、声音处理、图像处理、垃圾邮件分类与拦截，网页检索、基因诊断以及股票预测等各个方面，都有着广泛的应用。这一类机器学习的典型任务包括：预测数值型数据的回归，预测分类标签的分类，预测顺序的排序等。</p>
<p><strong>无监督学习</strong>，是指在没有老师的指导下，学习自学的过程。在机器学习里，基本上都是计算机在互联网中自动收集信息，并从中获取有用的信息。无监督学习不仅仅局限于解决像监督学习那样的有明确答案的问题，因此，它的学习目标可以不必十分明确。无监督学习在人造卫星故障诊断、视频分析、社交网站解析和声音信号解析等方面大显身手的同时，在数据可视化以及作为监督学习方法的前处理工具方面，也有广泛的应用。这一类机器学习的典型任务有聚类、异常检测等。</p>
<p><strong>强化学习</strong>，与监督学习类似，也以使计算机获得对没有学习过的问题作出正确解答的泛化能力为目标，但在学习过程中，不设置老师提示对错，告知最终答案的环节。然而，如果真的在学习过程中不能从环境中获得任何信息的话，强化学习就变成无监督学习了。强化学习，是指在没有老师直到的情况下，自己对预测的结果进行评估的方法。通过这样的自我评估，学生为了获得老师的最高嘉奖而不断地进行学习。强化学习，在机器人的自动控制、计算机游戏中的人工智能、市场战略的最优化等方面均有广泛的应用。在强化学习中国经常会用到回归、分类、聚类、和降维等各种机器学习算法。</p>
<h2 id="1-2_机器学习任务的例子">1.2 机器学习任务的例子</h2><p>下面主要讲解机器学习中典型的任务，例如回归、分类、聚类、异常检测、聚类和降维等。</p>
<p><strong>回归</strong>，是指把实函数在样本点附近加以近似的有监督的函数近似问题。考虑以$d$维实向量$\boldsymbol{x}$作为输入，实数值$y_i$作为输出的函数$ y=f(\boldsymbol{x}) $的学习问题。在监督学习里，这里的真实函数关系$f$是未知的，作为训练集的输入输出样本<span>$\{({x_i}, y_i)\}_{i=1}^{n}$</span><!-- Has MathJax -->是已知的。</p>
<p><strong>分类</strong>，是指对于指定的模式进行识别的有监督的模式识别问题。在这里，以$d$维实向量$\boldsymbol{x}$作为输入样本，而所有的输入样本，可以划分为$c$个类别的问题进行说明，作为训练集的输入输出样本<span>$\{({x_i}, y_i)\}_{i=1}^{n}$</span><!-- Has MathJax -->是已知的。但是，分类问题中的输出样本$y_i$，并不是具体的实数，而是分别代表类别$ 1,2, \ldots ,c $。在这样的任务里，得到输出类别$1,2, \ldots ,c$的函数$ y=f(\boldsymbol{x}) $的过程。</p>
<p><strong>异常检测</strong>，是指寻找输入样本<span>$\{({x_i})\}_{i=1}^{n}$</span><!-- Has MathJax -->中所包含的异常数据的问题。在已知正常数据与异常数据例子的情况下，其与有监督的分类问题是相同的。但是，在一般情况下，对于什么样的数据是异常的，什么样的数据是正常的，在事先是未知的。在这样的无监督的异常检测问题中，一般采用密度估计的方法，把靠近密度中心的数据作为正常数据，把偏离密度中心的数据作为异常数据。</p>
<p><strong>聚类</strong>，与分类问题相同，也是模式识别问题，但是属于无监督学习的一种。即只给出输入样本<span>$\{({x_i})\}_{i=1}^{n}$</span><!-- Has MathJax -->，然后判断各个样本分别属于$1,2, \ldots ,c$中的哪个簇。隶属于相同簇的样本之间具有相似性的性质，不同簇之间具有不同的性质。在聚类问题中，如何准确地计算样本之间的相似度是很重要的课题。</p>
<p>参考文献：<br>[1] 图解机器学习<br>[3] <a href="http://pages.cs.wisc.edu/~jerryzhu/pub/sslicml07.pdf‎" target="_blank" rel="external">Semi-Supervised Learning Tutorial</a></p>
]]></content>
    <summary type="html">
    <![CDATA[机器学习入门]]>
    
    </summary>
    
      <category term="machine learning" scheme="http://whatsme.net/tags/machine-learning/"/>
    
      <category term="academic" scheme="http://whatsme.net/categories/academic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Range Sum Query]]></title>
    <link href="http://whatsme.net/2015/11/28/Range-Sum-Query/"/>
    <id>http://whatsme.net/2015/11/28/Range-Sum-Query/</id>
    <published>2015-11-28T05:56:19.000Z</published>
    <updated>2015-11-29T07:54:55.953Z</updated>
    <content type="html"><![CDATA[<p>Range Sum Query, 对一个整数序列，给定范围对其求和。根据序列的维度可分为一维、二维和多维，根据元素是否可以改变分为Immutable和Mutable，我们只讨论一维和二维的情况。<br><a id="more"></a></p>
<h2 id="1-_1D,_Immutable（一维，数据不可变）">1. 1D, Immutable（一维，数据不可变）</h2><blockquote>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p><strong>Example:</strong><br>Given nums = [-2, 0, 3, -5, 2, -1]</p>
<p>sumRange(0, 2) -&gt; 1<br>sumRange(2, 5) -&gt; -1<br>sumRange(0, 5) -&gt; -3<br><strong>Note:</strong></p>
<ol>
<li>You may assume that the array does not change.</li>
<li>There are many calls to sumRange function.</li>
</ol>
</blockquote>
<h3 id="Analysis">Analysis</h3><p>如果采取<em>brute-force</em>, 在每次query的时候，则需要用O(n)的时间复杂度计算sumRange(i, j)，整个时间复杂度就为O(n^2),这样做必然是会超时，因此这种方法不可行。</p>
<p>这种方法在每次query的时候都需要将i到j的元素累加，比如第一次query的是(0,2)，第二次query的是(0,3), 我们可以发现第二次的计算是可以利用第一次的结果的。因此可以对算法进行改进，在一开始进行适当的计算，并保存结果，在增加空间复杂度的前提下减小时间复杂度。最后在query的时候就可以节省大量时间了，那么关键是我们要保存什么信息呢？<br>可以发现：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sumRange</span><span class="params">(i, j)</span></span> = <span class="function"><span class="title">sumRange</span><span class="params">(<span class="number">0</span>, j)</span></span> - <span class="function"><span class="title">sumRange</span><span class="params">(<span class="number">0</span>, i-<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>假如我们已经计算了每个sumRange(0, k),那么我们既可以在O(1)的算法时间复杂度内完成query。计算所有的sumRange(0, k)可以利用动态规划，O(n)的时间即可完成。因此整个算法的时间复杂度为O(n)，空间复杂度也为O(n)。</p>
<h3 id="Cpp_Code">Cpp Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NumArray &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        cusums.resize(n+<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// cusums[0]=0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cusums[i] += cusums[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cusums[j+<span class="number">1</span>]-cusums[i];</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cusums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<h2 id="2-_2D,_Immutable（二维，数据不可变）">2. 2D, Immutable（二维，数据不可变）</h2><blockquote>
<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).<br><img src="/images/range_sum_query_2d.png" alt="Range Sum Query 2D" style="width: 200px;"><br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<p><strong>Example:</strong><br>Given matrix = [<br>    [3, 0, 1, 4, 2],<br>    [5, 6, 3, 2, 1],<br>    [1, 2, 0, 1, 5],<br>    [4, 1, 0, 1, 7],<br>    [1, 0, 3, 0, 5]<br>]<br>sumRegion(2, 1, 4, 3) -&gt; 8<br>sumRegion(1, 1, 2, 2) -&gt; 11<br>sumRegion(1, 2, 2, 4) -&gt; 12<br><strong>Note:</strong><br>You may assume that the matrix does not change.<br>There are many calls to sumRegion function.<br>You may assume that row1 ≤ row2 and col1 ≤ col2.</p>
</blockquote>
<h3 id="Analysis-1">Analysis</h3><p>与1维的处理方法相同，只不过二维的情形需要O(n^2)的时间预处理。主要利用一下公式：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sumRegion</span><span class="params">(row1, col1, row2, col2)</span></span> = </span><br><span class="line">                          <span class="function"><span class="title">sumRegion</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, row2, col1)</span></span></span><br><span class="line">                        + <span class="function"><span class="title">sumRegion</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, row1, col2)</span></span></span><br><span class="line">                        - <span class="function"><span class="title">sumRegion</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, row1, col1)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在实际处理中，定义积分图矩阵integrogram的第一行和第一列为0,方便使用统一公式处理，不用讨论为0的情况。</p>
<h3 id="Cpp_Code-1">Cpp Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NumMatrix &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix) &#123;</span><br><span class="line">        n = matrix.size();</span><br><span class="line">        m = n != <span class="number">0</span> ? matrix[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        integrogram.resize(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));  <span class="comment">// 第一行，第一列为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                integrogram[i][j] = integrogram[i-<span class="number">1</span>][j] </span><br><span class="line">                                  + integrogram[i][j-<span class="number">1</span>] </span><br><span class="line">                                  - integrogram[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                                  + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row1 &lt; <span class="number">0</span> || col1 &lt; <span class="number">0</span> || row2 &gt; n || col2 &gt; m)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> integrogram[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - integrogram[row2+<span class="number">1</span>][col1] - integrogram[row1][col2+<span class="number">1</span>] + integrogram[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; integrogram;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumMatrix numMatrix(matrix);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(0, 1, 2, 3);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(1, 2, 3, 4);</span></span><br></pre></td></tr></table></figure>
<h2 id="3-_1D,_Mutable_(一维，数据可变)">3. 1D, Mutable (一维，数据可变)</h2><blockquote>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>The update(i, val) function modifies nums by updating the element at index i to val.<br><strong>Example:</strong><br>Given nums = [1, 3, 5]</p>
<p>sumRange(0, 2) -&gt; 9<br>update(1, 2)<br>sumRange(0, 2) -&gt; 8<br><strong>Note:</strong></p>
<ol>
<li>The array is only modifiable by the update function.</li>
<li>You may assume the number of calls to update and sumRange function is distributed evenly.</li>
</ol>
</blockquote>
<h3 id="Analysis-2">Analysis</h3><p>在Immutable的基础上，增加了<strong>update(index, value)</strong>， 即可以改变序列中任何位置的值。显然如果再使用刚才的算法，由于update的最大时间复杂度为O(n),因此整个算法的时间复杂度就增加到了O(n^2),因此需要一个复杂度更低的算法。可以从两方面入手<em>update</em>和<em>query</em>。需要将这两个函数的复杂度都降低到O(logn)以下(包括O(logn))。前面已经提到过需要<strong>*事先进行一些预处理，使得一些重复计算的东西不再重复计算，才能够将复杂度降低下来</strong>。</p>
<p>先预先计算一些区间的和值，然后把每个询问都拆成若干个计算了和的区间，并且将这些区间的和再相加，从而得出答案。这不就是线段树的思想吗？那就先从线段树说起。</p>
<p>线段树其实本质就是用一棵树来维护一段区间上和某个子区间相关的值——例如区间和、区间最大最小值一类的。它的具体做法是这样的，这棵树的根节点表示了整段区间，根节点的左儿子节点表示了这段区间的前半部分，根节点的右儿子节点表示了这段区间的后半部分——并以此类推，对于这棵树的每个节点，如果这个节点所表示的区间的长度大于1，则令其左儿子节点表示这段区间的前半部分，令其右儿子表示这段区间的后半部分。以一段长度为10的区间为例，所建立出的线段树应该是这样子的。<br><img src="/images/segment_tree_1.png" alt="segment tree"><br>就以RSQ(Range Sum Query)问题为例吧——RSQ问题要求的是求解一段区间中的和值，那么我不妨效仿ST算法，先对一些可能会用到的区间求解这个和值！而既然我要是用线段树来解决这个问题的，那么我不妨就将每一个节点对应的区间中的和值都求解出来。</p>
<p>那给定这样一组数据，将这个预处理的结果给我计算一下？<br><strong>N=10</strong><br><strong>Weight = {3, 2, 9, 6, 7, 5, 4, 1, 8, 10}</strong><br>这数据正好也只有10个位置，那么直接用这棵树了。由于每个非叶子节点所对应的区间都正好由它的两个儿子节点所对应的区间拼凑而成，这样一个节点所对应的区间中的和值便是它的两个儿子节点所对应的区间的和。这样我只需要O(N)的时间复杂度就可以计算出这棵树来。”<br><img src="/images/segment_tree_2.png" alt=""><br>这样一棵树统计出来的区间怎样使用很快的算法进行查询？还有修改呢？”</p>
<p>先从简单的说起吧——<strong>修改</strong>，当某个位置的商品的重量发生改变的时候，对应的，就是这棵树的某个叶子节点的值发生了变化，包含这个节点的区间，便只有这个节点的所有祖先节点，而这样的节点数量事实上是很少的——只有O(log(N))级别。也就是说，当一次修改操作发生的时候，我只需要改变数量在O(log(N))级别的节点的值就可以完成操作了，修改的时间复杂度是O(log(N))。”</p>
<p><strong>查询</strong>这个问题其实也不复杂！从线段树的根开始，对于当前访问的线段树节点t, 设其对应的区间为[A, B], 如果询问的区间[l, r]完全处于前半段或者后半段——即r &lt;= (A + B)/2或者l &gt; (A + B) / 2，那么递归进入t对应的子节点进行处理（因为另一棵子树中显然不会有任何区间需要用到）。否则的话，则把询问区间分成2部分[l, (A + B) / 2]和[(A + B) / 2 + 1, r]，并且分别进入t的左右子树处理这两段询问区间（因为2棵子树中显然都有区间需要用到）！当然了，如果[A, B]正好覆盖了[l, r]的话，就可以直接返回之前计算的t这棵子树中的和值了。还是之前那个例子，如果我要询问[3, 9]这段区间，我的最终结果会是这样的——橙色部分标注的区间。<br><img src="/images/segment_tree_3.png" alt=""><br>首先[3, 9]分解成了[3, 5]和[6, 9]两个区间，而[3, 5]分解成了[3, 3]和[4, 5]——均没有必要继续分解，[6, 9]分解成了[6, 8]和[9, 9]——同样也没有必要继续分解了。每一步的分解都是必要的，所以这已经是最好的分解方法了。”</p>
<p>但是这样分解的话，区间的个数能保证么？万一很多怎么办？其实不会的，除了第一次分解成2个区间的操作可能会将区间个数翻倍外，之后每一次分解的时候所处理的区间都肯定有一条边是和当前节点对应的重合的（即l=A或者r=B），也就是说即使再进行分解，分解出的两个区间中也一定会有一个区间是不需要再进行分解的，也就是区间的总数是在深度这个级别的，所以也是O(logN)的。</p>
<p>再总结一下，首先根据初始数据，使用O(N)的时间构建一棵最原始的线段树，这个过程中我会使用子节点的值来计算父亲节点的值，从而避免冗余计算。然后对于每一次操作，如果是一次修改的话，我就将修改的节点和这个节点的所有祖先节点的值都进行更新，可以用O(logN)的时间复杂度完成。而如果是一次询问的话，使用上面描述的方法来对询问区间进行分解，用O(logN)的时间复杂度完成。无论是修改还是查询的时间复杂度都是O(logN)的，所以我这个算法最终的时间复杂度会是O(N + Q * log(N))。</p>
<h3 id="Cpp_Code-2">Cpp Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NumArray &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构建SegmentTree</span></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        segmentTree.resize(n * <span class="number">4</span> + <span class="number">1</span>);   <span class="comment">// 4n的空间足够存储SegmentTree</span></span><br><span class="line">        createTree(<span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(<span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &gt; n-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 沿根结点向下查询</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == i &amp;&amp; end == j)</span><br><span class="line">            <span class="keyword">return</span> segmentTree[node];</span><br><span class="line">        <span class="keyword">int</span> mid = (begin+end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &lt;= mid)    <span class="comment">// 位于左子树</span></span><br><span class="line">            <span class="keyword">return</span> query((node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, begin, mid, i, j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; mid) <span class="comment">// 位于右子树</span></span><br><span class="line">            <span class="keyword">return</span> query((node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>, mid+<span class="number">1</span>, end, i, j);</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 位于左子树和右子树</span></span><br><span class="line">            <span class="keyword">return</span> query((node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, begin, mid, i, mid)</span><br><span class="line">        + query((node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>, mid+<span class="number">1</span>, end, mid+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沿着根结点向下更新，直到叶子结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> id, <span class="keyword">int</span> val)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &lt; begin || id &gt; end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(begin == end)</span><br><span class="line">            segmentTree[node] = val;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            update((node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, begin, (begin+end)&gt;&gt;<span class="number">1</span>, id, val);</span><br><span class="line">            update((node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>, ((begin+end)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, end, id, val);</span><br><span class="line">            segmentTree[node] = segmentTree[(node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] + segmentTree[(node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建SegmentTree</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end &lt; begin)   <span class="comment">// illegal</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(begin == end) <span class="comment">//叶子结点</span></span><br><span class="line">            segmentTree[node] = nums[begin];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归构建左右子树</span></span><br><span class="line">            createTree((node &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, begin, (begin+end)&gt;&gt;<span class="number">1</span>, nums);</span><br><span class="line">            createTree((node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>, ((begin+end)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, end, nums);</span><br><span class="line">            segmentTree[node] = segmentTree[(node&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] + segmentTree[(node&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; segmentTree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.update(1, 10);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<p><strong>Summary</strong><br>对于本题，有人提出了一种基于bucket的方法，更新和查询分别需要O(1)和O(n^0.5)时间复杂度的算法<a href="https://leetcode.com/discuss/70272/solution-using-buckets-updating-for-query-the-worst-case-fast" target="_blank" rel="external">(more)</a>如果将求和该为求最大或最小值，即变成了RMQ问题，同样的算法，只需修改几个地方，就不再赘述，对于RMQ，还有经典的<a href="http://hihocoder.com/contest/hiho16/problem/1" target="_blank" rel="external">ST算法</a>。<br>另二维，数据可变的情况没有列出，读者可以自己思考。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Range Sum Query, 对一个整数序列，给定范围对其求和。根据序列的维度可分为一维、二维和多维，根据元素是否可以改变分为Immutable和Mutable，我们只讨论一维和二维的情况。<br>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://whatsme.net/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://whatsme.net/tags/leetcode/"/>
    
      <category term="tech" scheme="http://whatsme.net/categories/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Additive Number]]></title>
    <link href="http://whatsme.net/2015/11/27/Additive-number/"/>
    <id>http://whatsme.net/2015/11/27/Additive-number/</id>
    <published>2015-11-27T05:03:02.000Z</published>
    <updated>2015-11-29T07:09:35.152Z</updated>
    <content type="html"><![CDATA[<h2 id="Source">Source</h2><blockquote>
<p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p><strong>For example:</strong><br>“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.<br><em>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</em></p>
<p>“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.<br><em>1 + 99 = 100, 99 + 100 = 199</em></p>
<p><strong>Note:</strong> Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.<br>More: <a href="https://leetcode.com/problems/additive-number/" target="_blank" rel="external">leetcode</a></p>
</blockquote>
<a id="more"></a>
<h2 id="My_Solution">My Solution</h2><p>给定一个字符串，该字符串只包含0~9的字符，判断该字符串会否为“可加”的。“可加”的定义如下：将字符串序列分解为整数（至少三个），除了前两个，其余的每个数都是它前两个数之和。<br>根据字符串的不同分解，可构造一棵解答树，再利用深度优先搜索寻找答案，注意处理以下几点。</p>
<hr>
<ul>
<li>‘0x’是非法的；</li>
<li>数的长度越长，值越大，利用此性质可以有效的剪枝；</li>
<li>至少包含三个数。</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAdditiveNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span> )          <span class="comment">// three numbers at least</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>)   <span class="comment">// "0x" is illegal</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i+j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> first = str2int(num.substr(<span class="number">0</span>, i));</span><br><span class="line">                <span class="keyword">int</span> second = str2int(num.substr(i, j));</span><br><span class="line">                <span class="keyword">if</span>(dfs(num, first, second, i+j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// depth-first search</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> idx)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first+second == str2int(num.substr(idx)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.size()-idx+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[idx] == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> third = str2int(num.substr(idx, i));</span><br><span class="line">            <span class="keyword">if</span>(first+second == third)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(num, second, third, idx+i))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(first+second &lt; third) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// string to int</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">str2int</span><span class="params">(<span class="built_in">string</span> str)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.size();  </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || (str[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; n &gt; <span class="number">1</span>) )</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">            res = res*<span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Source">Source</h2><blockquote>
<p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p><strong>For example:</strong><br>“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.<br><em>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</em></p>
<p>“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.<br><em>1 + 99 = 100, 99 + 100 = 199</em></p>
<p><strong>Note:</strong> Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.<br>More: <a href="https://leetcode.com/problems/additive-number/">leetcode</a></p>
</blockquote>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://whatsme.net/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://whatsme.net/tags/leetcode/"/>
    
      <category term="tech" scheme="http://whatsme.net/categories/tech/"/>
    
  </entry>
  
</feed>
